/*\
 * Copyright (c) 2018 Sze Howe Koh
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
\*/

#include "lqapplication.h"
#include <QWidget> // For QWidget destructor
#include <QDebug>

/*!
	\class LQApplication

	The LQApplication class extends QApplication with glue code required
	to run a LabVIEW-driven Qt application.
*/

/*!
	\sa LQApplication::killWidgets(), stopWidgetEngine()
*/
LQApplication::~LQApplication()
{
	// killWidgets() should have already taken care of these, but just in case...
	// We must preemptively delete all widgets here. If we leave it up
	// to the QApplication destructor instead, it will try to query
	// the widgets' meta objects. However, those won't exist anymore after the
	// LQApplication destructor is done!
	for (auto widget : topLevelWidgets())
	{
		qWarning() << "Widget was not deleted before LQApplication:" << widget;
		delete widget;
	}

	// QMetaObjectBuilder creates these objects using malloc(),
	// so they must be free()'d.
	for(auto obj : lqMetaObjects)
		free(obj);
	for(auto obj : staleMetaObjects)
		free(obj);
}

void
LQApplication::registerEventRefs(LVUserEventRef* ref_void, LVUserEventRef* ref_bool, LVUserEventRef* ref_i32, LVUserEventRef* ref_dbl, LVUserEventRef* ref_string)
{
	// ASSUMPTION: These will always be registered before any connections are made.
	// No need to lock for thread-safety.
	this->ref_void = *ref_void;
	this->ref_bool = *ref_bool;
	this->ref_i32 = *ref_i32;
	this->ref_dbl = *ref_dbl;
	this->ref_string = *ref_string;
}

LQApplication::BindingStatus
LQApplication::bindingStatus(const QByteArray& className) const
{
	int index = lqIndex(className);
	if (index == -1)
		return Unbound;
	if (bindingFinalists[index])
		return Finalized;
	return Started;
}

/*!
	This function is intended to be called by the LQMetaBinding constructor,
	to register a dynamic meta object for a LabVIEW-created subclass of QObject
	(LQObject).

	The caller must ensure that:
		- \a className is non-empty, and is the unique name of the LabVIEW class.
		- \a prototype is a stub QMetaObject that has

	Returns the index number of the newly-registered LQObject.
*/
int
LQApplication::initializeBinding(const QByteArray& className, QMetaObject* prototype)
{
	int index = lqMetaObjects.count();

	bindingMap << className;
	bindingFinalists << false;
	lqMetaObjects << prototype;

	return index;
}

/*!
	This function is intended to be called very shortly after the construction
	of a custom QObject subclass, to register the signals of this custom class.
	It takes pointers to raw LabVIEW datatypes to avoid the conversion overhead
	if the object is already finalized.

	The caller must ensure that all \a signalList elements are well-formed.
*/
LQ::Error
LQApplication::finalizeBinding(QObject* _instance, LVArray<LStrHandle>** signalList, LStrHandle superClassName)
{
	if (!_instance)
		return LQ::NullPointerUseError;

	QByteArray className = _instance->metaObject()->className();

	auto status = bindingStatus(className);
	if (status == Finalized)
		return LQ::NoError; // Already finalized; don't need to do anything
	if (status == Unbound)
		return LQ::NotAnLQObjectError;

	// Augment the stub QMetaObject

	int index = lqIndex(className);
	QMetaObjectBuilder b(lqMetaObjects[index]);

	int superIndex = lqIndex( LVString::to<QByteArray>(superClassName) );
	if (superIndex >= 0)
		b.setSuperClass(lqMetaObjects[superIndex]);

	// TODO: Sanitize the signal signatures
	auto sigs = (*signalList)->toQList<QByteArray>();
	for (const auto& sig : sigs)
		b.addSignal(sig);

	// Avoid race condition: Don't delete the stub QMetaObject yet, in case a
	// different thread started reading from it just before we finalize the
	// class. Defer deletion till shutdown.
	staleMetaObjects << lqMetaObjects[index];
	lqMetaObjects[index] = b.toMetaObject();
	bindingFinalists[index] = true;

	return LQ::NoError;
}

/*!
	This function provides a way to gracefully delete all widgets before
	stopping the GUI event loop.

	Some complex widgets (e.g. QComboBox) don't like direct deletion, so
	we must ensure they receive and act on a QDeferredDeleteEvent.

	\sa LQApplication::~LQApplication(), stopWidgetEngine()
*/
void
LQApplication::killWidgets()
{
	for (auto widget : topLevelWidgets())
		widget->deleteLater();
}

/*!
	\class LQSignalRelay

	Instances of this class are designed to act as the "middle man" for
	signal-signal connections, when the second method in the connection
	is a LabVIEW-defined signal. These signals lack a function body
	generated by the meta-object compiler, so they need to be manually
	activated when the source signal is emitted.

	Each LQSignalRelay should only manage one connection.
*/

/*!
	The caller must ensure that this LQSignalRelay object lives in the same
	thread as the \a target, and must invoke this function in that thread.

	\a signalIndex must refer to a valid signal in the \a target that is
	compatible with the active slot of this LQSignalRelay object.
*/
void
LQSignalRelay::finalize(QObject *target, int signalIndex)
{
	setParent(target);
	this->signalIndex = signalIndex;
}

void
LQSignalRelay::activate_impl(void* dataAddr) const
{
	void* argv[]{nullptr, dataAddr};
	QMetaObject::activate(parent(), signalIndex, reinterpret_cast<void**>(argv));
}
